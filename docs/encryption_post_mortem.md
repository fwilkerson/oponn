# Post-Mortem: AWS Encryption SDK Integration

## 1. Executive Summary
The goal was to implement column-level envelope encryption with local data key caching for the `oponn` project. While the final implementation is functional and verified, the process revealed significant friction within the **AWS Encryption SDK for Python (v4.x)**.

## 2. Technical Challenges & "Circles"

### 2.1 The "Dafny" Implementation Gap
The modern Material Providers Library (MPL) used in v4 is transpiled from Dafny. This introduced the `"No impl found on the operation config"` error. The library requires a complex initialization of its internal Dafny implementation which is poorly documented for standalone Python use.

### 2.2 Architectural Mismatch (The Block)
We attempted to move to the modern **Keyring** pattern, but hit a fundamental class hierarchy mismatch:
*   **The SDK's Caching Manager** (`CachingCryptoMaterialsManager`) strictly requires its backing manager to be an instance of the SDK's legacy `CryptoMaterialsManager` class.
*   **The Modern MPL Manager** (`DefaultCryptographicMaterialsManager`) is generated by the MPL library and **does not** inherit from the SDK's legacy base class.
*   **Result:** You cannot wrap a modern Keyring-based manager in the standard SDK caching manager without triggering a `TypeError`.

### 2.3 Type Hint Hostility
The SDK is not PEP 561 compliant (no `py.typed`). In a project using strict type checking (`basedpyright`), this resulted in over 50+ warnings/errors regarding "Unknown" types and incompatible overrides, forcing the use of many `# type: ignore` markers.

### 2.4 Namespace Fragmentation
The migration from v3 to v4 moved many critical classes (like the CMM and Cache) from submodules to the top-level namespace, but many official AWS code examples and StackOverflow threads still reference the old, now-broken paths.

## 3. Why we "Retreated" to Legacy (MKP)
Despite our efforts to use the modern v4 Keyring way, we reverted to the **Master Key Provider (MKP)** pattern because:
1.  **Native Integration:** The MKP pattern is natively supported by the SDK's `CachingCryptoMaterialsManager`.
2.  **Stability:** It avoids the "No impl found" transpilation errors.
3.  **Correctness:** It still uses modern algorithms (AES-GCM) and enforces "Key Commitment" when used with v4 of the client, providing the same security benefits as Keyrings but without the configuration friction.

### 3.1 GitHub Research Findings
Research into the `aws-encryption-sdk-python` repository confirms this is a known "Feature Gap":
*   **The Intent:** AWS is moving away from `CachingCMM` in favor of the **`AwsKmsHierarchicalKeyring`**. 
*   **The Problem:** The Hierarchical Keyring is currently specific to AWS KMS. For developers using `RawAesKeyring` (like our local setup), there is **no modern replacement** for the `CachingCMM` yet.
*   **The Result:** Developers who need caching with non-KMS keys are explicitly advised to continue using the "Legacy" Master Key Providers until the MPL library provides a generic Caching CMM.

## 4. Lessons Learned
*   **"Brand Name" != "Developer Experience":** Just because a library is from AWS doesn't mean it follows modern Python standards or provides a smooth DX.
*   **The Cost of Transpilation:** Libraries transpiled from other languages (like Dafny) often bring "baggage" that breaks standard IDE features and type checkers.
*   **Documentation Lag:** In libraries undergoing major version transitions, the delta between "Official Docs" and "Actual Runtime Behavior" can be massive.

## 5. Better Alternatives for Future Projects
If this were to be implemented again from scratch:
1.  **Google Tink:** Highly recommended. Native Python types, high-level safe defaults, and zero transpilation issues.
2.  **Manual Envelope Pattern:** Use the `cryptography` library directly. It is much lighter, fully typed, and would have required less total code than the AWS SDK boilerplate.
